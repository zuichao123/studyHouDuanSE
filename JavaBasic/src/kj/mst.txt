==  和 equals  的区别
     ==  对于基本类型来说是值⽐较；
     ⽽对于引⽤类型⽐较的是引⽤，是否是指向同⼀个对象的引⽤。

    equals  默认是引⽤⽐较；
    ⽽ Integer、String 等包装类都重写了 equals ⽅法，改为了值⽐较。

    所以对象都可以看作是继承⾃ Object ，如果⾃定义类未覆写equals，调⽤对象实例的 equals ⽅法默认是引⽤⽐较。

String/StringBuffer/StringBuilder的区别
    String 为不可变字符串；StringBuffer 和 StringBuilder 为字符串可变对象。
    String 的 substring 等修改操作每次都会产⽣⼀个新的 String 对象；
    字符串拼接性能 String 低于StringBuffer，⽽ StringBuffer 低于 StringBuilder。
    StringBuffer 是线程安全的，StringBuilder ⽽线程不安全的。
    StringBuffer和StringBuilder⼆者都是继承⾃ AbstractStringBuilder；
    它们的唯⼀区别是 StringBuffer 的所有⽅法都使⽤了 synchronized 修饰符来保证线程安全。

String 对象的 intern 的作⽤
    String 对象的 intern ⽅法⽤于字符串的显示排重。
    调⽤此⽅法时，JVM 去字符串常量池查找池中是否已经存在该字符串，如果已存在则直接返回它的引⽤；如果不存在则在池中先创建然后返回其引⽤。

String 不可变性的优点
    字符串不可变，因此可以通过字符串常量池来实现，共享对象，从⽽节省空间，提⾼性能。
    多线程安全，因为字符串不可变，所以当字符串被多个线程共享时不会存在线程安全问题。
    适合做缓存的 Key，因为字符串不可变，因此它的哈希值也就不变；创建时它的哈希值就被缓存了，不需要重新计算，速度更快。

String 是否可以被继承
    String 不能被继承。因为 String 被声明为 final，所以不能被继承。

抽象类和接⼝的定义、特性与区别
    动物这种概念性的东西，就用抽象类；而飞，跑，吃这些行为就用接口

    抽象类：
        抽象类是为类继承而存在的，不能用抽象类创建对象，也就这个抽象类不能做任何事情。
        对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求进行不同的实现，那么可以将这个方法声明为abstract方法，这个类就是abstract抽象类

    接口：
        是对一种行为的规范。
        接⼝就是抽象⽅法和全局常量的集合，在Java中接⼝使⽤interface关键字定义

    区别：
        1.语法层面上的区别
            1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；
            2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
            3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
            4）一个类只能继承一个抽象类，而一个类却可以实现多个接口

        2.设计层面上的区别
            1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。
               抽象类是对整个类整体进行抽象，包括属性、行为
               但是接口却是对类局部（行为）进行抽象

               举个简单的例子，
                   飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。
                   那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，
                   但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。
                   此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。
                   然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。
                   从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，
                   而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。

            2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。
               而接口是一种行为规范，它是一种辐射式设计。

               什么是模板式设计？
                    最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，
                    如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，
                    比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，
                    可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。

        序号       区别              抽象类                             接口
        1          结构组成          普通类+抽象方法                    抽象方法+全局常亮
        2          权限              各种权限                           public
        3          子类使用          使用extends关键字继承抽象类        使用implements关键字实现接口
        4          关系              一个抽象类可以实现若干个接口       接口不能继承抽象类，但是可以使用extends关键字继承多个接口
        5          子类限制          一个子类只能继承一个抽象类          一个子类可以实现多个接口

抽象类和接⼝主要是解决什么编程问题
    抽象类
        基类，当父类的一些方法不能确定时

    接口
        接口体现了程序设计的多态和高内聚低偶合的设计思想。
        实现接口可在不打破继承关系的前提下，对某个类功能扩展，非常灵活


抽象⽅法可以被 private 修饰吗？为什么
    抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类无法实现该方法），缺省情况下默认为public

接⼝能不能有⽅法体？
    Java 8 版本开始对接⼝做了以下增强
        在⽅法声明前添加 default 关键字时，则可以为该⽅法编写⼀个默认实现，这个特征叫默认⽅法或
        者扩展⽅法；但是默认⽅法不能覆盖 Object 中的⽅法，却可以重载 Object 中的⽅法。

        接⼝⾥可以声明静态⽅法，静态⽅法必须有⽅法体


内部类有哪些种类？
    成员内部类：存在于某个类的内部，与全局属性或者方法同级的内部类就是成员内部类；
        特点
            成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括静态成员和私有成员）。
            成员内部类和外部类的属性和方法名同名时，外部类的属性和方法会隐藏；但可以通过外部类.this.成员变量的方式访问外部类的属性和方法。
            外部类必须通过成员内部类的对象来访问内部类的属性和方法。
            成员内部类对象会隐式的引用一个外部类对象。（可以解释第一点）
            成员内部类可以有public\private\protected以及默认访问权限。

    局部内部类：是定义在一个方法或者一个作用域里面的类。它与成员内部类的区别在于局部内部类的访问仅在于方法内或者作用域内
        特点
            不能有private、public、protected和static等修饰符，与局部变量类似。
            只能在定义局部内部类的方法或者作用域中实例化；
            局部内部类的对象不能使用该内部类所在方法或者作用域的非final局部变量（为什么？）；

    匿名内部类：不定义类的名字，在使用的地方直接定义对象
        特点
            唯一一种没有构造器的类；匿名内部类在编译时，编译器会自动起名xxx$1.class;
            匿名内部类不能存在任何静态的变量、方法等；
            匿名内部类是局部内部类的特例；
            大部分匿名内部类用于接口返回；

    静态内部类：在成员内部类的基础上加上一个static关键字就是静态内部类。
        特点
            不需要依赖外部类。
            不能使用外部类的非静态属性和方法。


内部类和局部内部类的区别？
    内部类：
        内部类是指在一个外部类的内部再定义一个类。
        内部类作为外部类的一个成员，并且依附于外部类而存在的。
        内部类可为静态，可用protected和private修饰（而外部类只能使用public和缺省的包访问权限）

    局部内部类：
        不能使⽤ public、protected 或 private 访问修饰符进⾏声明，它的作⽤域被限定在声明这个局部类的块中。
        局部内部类只在当前方法中有效。
        局部内部类中不能定义 static 成员。
        和其他内部类相⽐，局部内部类除了可以访问包含它的外围类外，还可以访问作⽤域范围内的局部变量。但是，这些局部变量必须被声明为 final。


内部类的作⽤？
    内部类方法可以访问该类定义所在的作用域中的数据，包括私有数据。
    内部类可以对同一个包中的其他类隐藏起来。
    当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。


内部类可以被继承吗？
    内部类和其他普通类一样，同样可以被继承，这样给本来就十分灵活的内部类增加了更好的结构性和代码复用性。
    只是内部类的继承和普通类有一些不同之处，是在使用时需要多加注意的。
    因为内部类在创建时需要外部类的引用，所以在内部类的继承上也需要外部类的协助。


匿名内部类可以有静态成员变量和静态⽅法吗？为什么？
    匿名内部类不能存在任何静态的变量、方法
    因为
        static类型的属性和方法，在类加载的时候就会存在于内存中。
        要想使用某个类的static属性和方法，那么这个类必须要加载到虚拟机- 中。
        非静态内部类并不随外部类一起加载，只有在实例化外部类之后才会加载。

        现在考虑这个情况：在外部类并没有实例化，内部类还没有加载，这时候如果调用内部类的静态成员或方法，
        内部类还没有加载，却试图在内存中创建该内部类的静态成员，这明显是矛盾的。所以非静态内部类不能有静态成员变量或静态方法。


什么是代理？什么是动态代理？
    代理

    动态代理
        Proxy类的代码量被固定下来，不会因为业务的逐渐庞大而庞大；
        可以实现AOP编程，实际上静态代理也可以实现，总的来说，AOP可以算作是代理模式的一个典型应用；
        解耦，通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。


动态代理和cglib代理的区别？


简述⼀下 Spring AOP 的实现？


